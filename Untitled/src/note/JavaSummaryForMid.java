package note;

public class JavaSummaryForMid {
	public static void main(String[] args) {
		/*
		 * 1. 변수 : 기본형, 참조형 등의 데이터값을 저장하는 메모리 공간, 
		 * 
		 * 1) 변수의 유형 
		 * 	- 기본형 : 메모리에 실제 값이 저장되는 변수형, int, long, double... 
		 * 	- 참조형 : 메모리의 특정 객체(Instance)의 주소지를 가리키는 변수형, String, Random .. 
		 * 
		 * 2) 변수 선언방법
		 * 	 - 선언법 1) : Type 변수명(Value);
		 * 	 - 선언법 2) : Type 변수명 = 초기화 값;
		 * 
		 *   - 변수명 선언규칙 (컴파일)
		 *     1) 예약어 금지
		 *     2) 첫글자로 숫자 사용X 
		 *     3) 특수문자는 '$', '_' 빼고 포함 금지 
		 *     4) 공백을 사용할수 없다 '_' 표기 가능
		 *   
		 *   - 변수명 선언규칙 (사용 할 때) 
		 *     - 카멜표기법 = 첫글자가 소문자, 
		 *     - 단 상수는 예외로 대문자가 사용 가능하다.
		 * 
		 * 3) 기본형	총 8개, 메모리에 실제 값이 상주하는 데이터
		 *	- 정수형
		 *		byte  : 1byte
		 *		short : 2byte
		 *		int   : 4byte
		 *		long  : 8byte  // 끝에 l , L 써야된다.
		 *	- 실수형
		 *		float  : 4byte	// 끝에 f , F 써야 된다.
		 *		double : 8byte  
		 *
		 *	- 문자형
		 *		char   : 2byte // why? : char은 유니코드 문자이고 유니코드의 크기가 2byte
		 *	
		 *	- 논리형	
		 *		boolean : 1byte, true, false
		 * 
		 * 4) 참조형	=	 메모리주소를 Link하는 값
		 *   - Class Type으로 선언된 형
		 *   - 실제 객체는 Heap에 생성되고 참조형 변수로 주소값에 접근할 수 있다.
		 *   - new로 키워드 생성
		 *   - 초기화 값은 null로 초기화 한다.
		 *   - ex.) String : 문자열, Random : random 수에 관련된 기능
		 * 
		 * 5) Type casting (형변환)
		 *  - 강제 형변환	(명시적)
		 *  	: 변수1 = (Type)변수2; 으로 사용한다.	(직접 입력)
		 *  	: 사용자가 큰타입 -> 작은 타입으로 변환시킬 때 사용한다.
		 *      : 사용하지 않으면 casting exception이 발생하다.
		 *      : 데이터가 손실됨을 인지하고 써야한다.
		 *  	long v1; int v2; ... v2 = (int)v1;
		 *  
		 *  - 자동 형변환	(묵시적)
		 *		: 작은타입 -> 큰타입으로 변환될때 별다른 문법 없이 사용된다.
		 *		: 특별한 문제가 없어 에러가 발생하지 않는다.
		 *
		 * 6) Overflow
		 *  - 변수의 크기를 넘어선 연산을 할때 사용자가 예측하지 못하는 값으로 들어오는 현상(허용된 범위 이상을 침범했을 때)
		 *  - byte value = 127; 127++ 순간 -> -128로 바뀌는 현상
		 *  
		 *  
		 * 7) 상수 : 한번 선언되고 초기화 된 이후 절대 변하지 않는 수
		 * 	- 변수 앞에 final을 쓴다.
		 *    ex) final int MAX_SIZE = 10; 
		 * 
		 * 
		 * 2. 연산자 (operator) : 정해진 규칙으로 연산을 진행시키는 문법
		 * 1) 연산자 우선순위
		 * 	- 최우선 연산자 : 직접 접근 연산자 -> '( )' '.' '{ }'
		 * 	- 단항 연산자 : 산술/쉬프트(>> << >>>)/비교(> <ㅡ >= <= == !=)/논리(비트/일반)
		 *  - 이항 연산자	||, &&, 
		 *  - 삼항 연산자	a>b? "c": "d":
		 *  - 대입 연산자 : / 순수(=) / 복합대입(+= , *=)
		 *  - 나열 연산자 : ,
		 *  
		 * 	
		 * 2) 최우선 연산자(직접 접근 연산자)
		 * 	- () : 괄호 최우선
		 *  - .  : 객체에서 내부 메소드/변수 참조 할 때
		 *  - {} : 블록 처리할때
		 *  
		 * 3) 단항 연산자 
		 *  - '+' '-' : 양수 음수
		 *  - '++' '--' : 값 자체에 1증감, 1감소 연산 할 때.
		 *          ++i : 전위 연산, 다른 연산 이전에 더함
		 *          i++ : 후위 연산, ';' or 라인이 끝나고 더함
		 *  - ! : 논리값 부정할때, !isTrue
		 *  - ~ : 비트값에 'not' 연산자.  0b0001 = 0b1110  // X
		 *  - (Type) : Type casting 할 때
		 * 
		 * 4) 이항연산자 
		 *  - *산술연산자 : /*%  +-
		 *     - %는 나머지 값 계산할때 사용
		 *  - 쉬프트 연산자 : >>  <<  >>>  // X
		 *  	// shift뜻 : 이동한다? 옮긴다.  
		 *       ex) 0010 << 1 = 0100 
		 *  - 비교연산자 : > < >= <=
		 *  - 논리연산자 (비트) : & ^ |  앞쪽이 우선순위 높음 // X
		 *  - *논리연산자 (논리) : && ||  앞쪽이 우선순위 높음
		 *  	- (논리식) && (논리식)
		 *      - && : 1 && 1 = 1, 1 && 0 = 0, 0 && 1 = 0, 0 && 0 = 0 // 1=true/0=false
		 *      	※ 주의 : 앞이 거짓이면, 뒤에 논리식 실행 안함.
		 *      - || : 1 || 1 = 1, 1 || 0 = 1, 0 || 1 = 1, 0 || 0 = 0 // 1=true/0=false
		 *      	※ 주의 : 앞이 참이면, 뒤에 논리식 실행 안함.
		 *      
 		 * 
		 * 3) 삼항 연산자
		 *  - (조건식) ? 참일때의 값 : 거짓일때의 값;
		 *  - String result = (isTrue == true) ? "참입니다." : "거짓입니다.";
		 * 
		 * 4) 대입 연산자
		 *  -순수대입 : =  값을 대입할때 사용 
		 *     ex) a = b;
		 *  -복합 대입 (산술, 쉬프트, 비트논리)
		 *    산술 : += -= *= /= %=
		 *    쉬프트 : <<= >>= >>>= // X
		 *    비트논리 : &= ^= \=  // X
		 *  
		 *  5) 나열 연산자
		 *  - ',' 표기
		 *     int i = 0, j = 0; // 절대 금지.   
		 *     
		 * 
		 * 3. 조건 - if / switch
		 *  1) if 문 
		 *    if (조건식) { // true or false 
		 *    
		 *    } else if(조건식){ // else if는 중첩되서 여러 사용 가능
		 *    
		 *    } else { 
		 *    	// 나머지 값
		 *    } 
		 *    
		 *    
		 *  2) switch 문
		 * 		switch (value) { value : int, char, String, // 열거형....
		 * 			case 1 : 
		 *     			break;
		 * 			case 2 :  // break를 생략 가능
		 * 			case 3 :  // 2,3 동시에 처리할때.
		 *     		default :
		 *     			// 이외 값 처리
		 *     			break;
		 * 		}
		 * 
		 * 4. 반복문 - while, do while, for
		 *	1) while 
		 *		while (조건식){
		 *			조건식이 참일 경우 진입.
		 *		}		
		 *
 		 *	2) do while // X 
		 *		do {
		 *			//	무조건 처음은 실행된다. 
		 *		} while(조건식)
		 *
		 *  3) for
		 *  	for(초기화문 : 조건식 : 증감식){
		 *  		// 조건식이 참일때 진입
		 *  	}	
		 *  
		 *  
		 *  4) break
		 *  	int i = 0;
		 *  	while(true){
		 *  		if(++i > 10)
		 *  			break;  // i가 0 ~ 9까지 반복 할 때, 반복문 끝으로 이동
		 *  	}
		 *  
		 *  5) continue
		 *  	while(true) {
		 *  		if(i++ % 2 == 0)
		 *  			continue; // 짝수 일때 진입하지 않는다. 반복문 시작점으로 이동
		 *  		print(i);
		 *  	}
		 *  
		 * 
		 * 반복, 종속
		 * + @ 교재 다 보기
		 * 논리연산자 공부!
		 * 복합 대입 연산자 공부!
		 * 
		 * 
		 * 서술형 8문제
		 * 문제해결형 = 문제를 주어주고 문제점에 대한 해결법까지 제시..
		 * 3문제 // 클래스 다이어그램 볼 줄 알기, 잘못된 코드 고치기(practice debug), +@ 문제?
		 * 
		 * 
		 * 
		 * 
		 * 
		 * 
		 * 
		 * 
		 * 객체 : 사물
		 * 객체의 상태와 행동을 구체화하는 형태의 프로그래밍 : 객체 지향 프로그래밍
		 *  1.클래스 : 객체 지향 프로그래밍의 추상화 개념을 직접 구현한 것과 유사, 설계도
		 *  선언 : public static class { }
		 *  클래스의 멤버 : 클래스 필드, 클래스 메소드;
		 *  
		 *  선언된 클래스로 인스턴스 생성
		 *  객체 참조를 위한 참조 변수 선언 -> 클래스이름 객체참조변수이름 -> Car myCar;
		 *  new 키워드로 인스턴스 생성 후 인스턴스의 주소를 미리 선언한 참조 변수에 저장하여 사용
		 *  -> myCar = new Car();
		 *  
		 *  참조 변수 선언 + 인스턴스 생성
		 *  -> Car myCar = new Car();
		 * 구성 : 객체의 상태, 속성을 나타내는 필드 + 객체의 행동을 나타내는 메소드 + 
		 * 생성된 객체의 필드를 초기화해주는 생성자
		 * 
		 *  2.인스턴스 : 클래스로부터 객체를 선언하는 과정은 인스턴스화, 선언된 해당 클래스 타입의 객체가 인스턴스
		 *  = 메모리에 할당된 객체를 의미
		 *  생성된 인스턴스는 독립된 메모리 공간에 저장된 자신만의 필드를 가질 수 있지만 
		 *  해당 클래스의 모든 메소드는 해당 클래스에서 생성된 모든 인스턴스가 공유한다.
		 *  
		 * 3.필드 : 클레스에 포함된 변수, 선언 위치에 따라 구분, 클레스의 멤버이며 클래스의 속성을 표현
		 * -> 클래스 변수, 인스턴스 변수, 지역 변수
		 * 
		 *  3-1. 종류
		 *  (멤버 변수)클래스 변수, 인스턴스 변수 :  초기화 필요 없이 변수 타입에 맞게 자동으로 초기화 된다. 
		 *  지역 변수 : 사용 전에 초기화 하지 않으면 컴파일러 오류 발생
		 *  
		 *  클래스 변수(static variable) : 클래스 영역에 위치한 변수 중 static 키워드를 가지는 변수,
		 *  클래스가 메모리에 올라갈 때 생성, 프로그램 종료 시 소멸, 메소드 영역에 메모리 저장; 
		 *  사용 방법 = 클래스 이름. 변수이름	== Class.classVariable
		 *  인스턴스 생성 없이도 바로 사용 가능 
		 *  -> 공유 변수라고도 하며 해당 클래스의 모든 인스턴스가 공유해야 하는 값을 유지하기 위해 사용됨
		 *   
		 *   
		 *  인스턴스 변수(instance variable) : 클래스 영역에 위치한 변수 중 static 키워드를 가지지 않는 변수, 
		 *  인스턴스와 생성, 소멸 시기 같음, Heap 영역에 메모리 저장; 
		 *  사용 방법 = 인스턴스 이름. 변수 이름 인스턴스마다 가져야 하는 고유한 값을 유지하기 위해 사용됨
		 *  
		 *  
		 *  지역 변수(local variable) : 메소드, 생성자, 초기화 블록 내에 위치한 변수, 
		 *  블록 내에서 변수의 선언문이 실행될 때 생성, 블록을 벗어나면 소멸, Stack 영역에 저장; 
		 *  사용 방법 = 변수이름
		 *
		 * 3-2. 초기화
		 * 변수의 타입에 맞게 자동으로 초기화되지만 지역 변수처럼 해 주는 것이 좋다
		 * 명시적 초기화(선언과 동시에 초기화), 
		 * 생성자를 이용한 초기화(객체의 생성과 동시에 필드 초기화)-> 인스턴스 생성시까지 필드 초기화 불가
		 * 
		 * 초기화 블록을 이용한 초기화 
		 * 초기화 블록 : 클래스 필드의 초기화만을 담당하는 중괄호로 둘러싸인 블록 의미, 생성자보다 먼저 호출
		 * 클래스 초기화 블록 : static 키워드로 정의, 클래스가 처음 메모리에 로딩될 때 한 번만 실행
		 * 생성자나 인스턴스 초기화 블록으로 수행할 수 없는 클래스 변수의 초기화를 수행할 때 사용
		 * 
		 * 인스턴스 초기화 블록 : 중괄호만 사용해서 정의 가능, 생성자와 마찬가지로 인스턴스 생성시마다 실행되지만
		 * 인스턴스 초기화 블록이 항상 생성자보다 먼저 실행된다. 생성자와 비슷해 인스턴스 초기화 블록은 잘 사용 ㄴㄴ
		 * 여러 개의 생성자가 있을 때 모든 생성자에서 공통으로 수행되어야 할 코드를 인스턴스 초기화 블록에 포함해
		 * 코드의 중복을 막을 수 있다
		 * 
		 * 필드의 초기화 순서
		 * 클래스 변수 : 기본값 - 명시적 초기화 - 클래스 초기화 블록
		 * 인스턴스 변수 : 기본값 - 명시적 초기화 - 인스턴스 초기화 블록 - 생성자
		 *  
		 *  4.메소드 : 클래스의 기능을 표현, 특정 작업을 수행하기 위한 명령문의 집합
		 *  목적 : 중복되는 코드 반복 방지, 모듈화로 가독성 향상, 유지보수 용이
		 *  문법 : 접근제어자(public) 반환타입(void) 메소드이름(매개변수목록) method(String name) 
		 *  선언부 {//구현부}
		 *  메소드의 반환형 종류 : void, 기본 자료형(type), 배열(배열의 주소값이 반환됨), 클래스(반환 값이 해당
		 *  클래스 타입의 객체일 경우 해당 객체의 주소값이 반환)
		 *  
		 *  하나의 클래스에 같은 이름의 메소드를 둘 이상 정의할 수 없지만 메소드 오버로딩으로 중복 정의 가능,
		 *  메소드 오버로딩 : 매개변수의 개수나 타입을 다르게하여 같은 이름의 또다른 메소드 작성 방법
		 *  -> 메소드 절약, 메소드를 호출할 때 전달해야 할 매개변수의 타입이나 개수를 신경 쓰지 않고 호출 가능
		 *  접근제어자 반환타입 메소드이름(매개변수목록) { }
		 *  접근제어자 : 해당 메소드에 접근 가능 범위 명시 / 
		 *  반환 타입 : 메소드가 모든 작업 끝내고 반환하는 데이터 타입 명시
		 *  매개변수 목록 : 메소드 호출 시에 전달되는 인자 값을 저장할 변수 명시
		 *  
		 *  메소드 시그니쳐 : 선언되는 매개변수 리스트, 두 메소드가 매개변수, 개수, 타입, 순서까지 다 같으면 시그니쳐가 같다
		 *  메소드 호출 과정
		 *  Car my car = new Car();	객체 생성
		 *  myCar.accelerate(60, 3);	myCar 인스턴스의 accelerate() 메소드 호출
		 *  
		 *  메소드의 구분 : static 여부에 따라
		 *  클래스 메소드(static method) : 클래스 변수처럼 인스턴스 생성 없이 바로 사용 가능
		 *  그러므로 클래스 메소드 내부에서 인스턴스 변수를 사용할 수 없음
		 *  -> 메소드 내부의 인스턴스 변수나 인스턴스 메소드를 사용하지 않는 메소드를 클래스 메소드로 정의하는 것이 일반적
		 *  
		 *  return 메소드 : 해당 메소드를 종료하고 반환 값을 가지고(있다면) 자신을 호출한 메소드로 돌아가는 예약어
		 *  
		 *  5.생성자 : 인스턴스를 만들 때 자동으로 값들을 초기화 해주는 함수? 클래스와 이름이 같음
		 *  생성과 동시에 인스턴스 변수를 원하는 값으로 초기화할 수 있음
		 *  반환 값이 없지만 반환 타입을 void형으로 선언하지 않는다 -> 클래스의 생성자는 어떠한 반환값도 명시하지 않음
		 *  초기화를 위한 데이터를 인수로 전달받을 수 있다
		 *  객체를 초기화하는 방법이 여러 개 존재할 경우 하나의 클래스가 여러 개의 생성자를 가질 수 있음
		 *  -> 생성자도 하나의 메소드이므로 메소드 오버로딩이 가능하다는 의미;
		 *  
		 *  new 키워드로 객체 생성시 자동으로 생성자 호출됨
		 *  기본 생성자 : 모든 클래스에는 하나 이상의 생성자가 정의되어 있어야 함, 아무런 매개변수, 명령어 ㄴㄴ
		 *  기본 생성자 : 클래스 이름() {}
		 *  클래스는 특별히 생성자를 정의하지 않고도 인스턴스 생성 가능 -> 컴파일러가 기본 생성자를 제공해주므로
		 *  
		 *  
		 *  6. 접근 제어자(access modifier) : 객체 지향 프로그래밍의 특징 중 하나인 정보 은닉을 위한 키워드
		 *  private : 선언된 클래스 내의 같은 private 멤버만 접근 가능 (private 메소드가 private 필드 호출)
		 *  
		 *  public : public 멤버는 프로그램 어디에서 누구나 접근 가능, public 메소드를 통해 
		 *  해당 객체의 private 멤버에 접근 가능 -> private 멤버와 프로그램 사이의 인터페이스 역할 수행
		 *  
		 *  default :  
		 *  
		 *  
		 *  
		 *  
		 *  
		 *  메모리 구조
		 *  모든 자바 프로그램: 자바 가상 머신(JVM)을 통해 실행 -> 운영체제가 JVM에게 필요 메모리 할당
		 *  JVM이 메모리 구분 : 메소드 영역 - 클래스 정보, 클래스 변수가 저장됨, 클래스 사용 시 클래스 파일을
		 *  읽어들여 해당 클래스에 대한 정보를 메소드 영역에 저장
		 *  힙 영역 : 동적 할당 영역, 모든 인스턴스 변수, 정보 저장됨, 메모리 주소값이 낮은 곳에서 높은 방향으로 할당
		 *  스택 영역 : 메소드가 호출될 때 지역변수, 매개변수 같은 메소드의 호출 정보(스택 프레임)가 저장됨,
		 *  메소드의 호출과 함께 할당, 메소드의 호출이 완료되면 소멸, 후입선출, 메모리의 주소값이 높은 곳에서 낮은 방향
		 *  으로 할당
		 *  
		 *  
		 *  
		 *  
		 *  
		 *  
		 *  
		 *  변수	(1)
		 *  변수 (캐스팅)	(3)	
		 *  연산자	(2)
		 *  제어문 If / switch	(3)
		 *  반복문  for / while	(5)
		 *  --------1차 평가 지필 범위----------
		 *  
		 *  
		 *  배열	(6)
		 *  2차원 배열	(8)
		 *  객체	(5)
		 *  --------1차 평가 실무형 범위---------
		 *  
		 *  
		 *  
		 *  객체배열	(9)
		 *  상속	(7)
		 *  
		 *  다형성	(8.5)		해야됨	-> 그림 잘 그리면 7
		 *  예외처리	(5)
		 *  컬렉션	(7)			-> 2차원 배열 대체할 것
		 *  스레드	(10)	==	전공자도 어렵고, 현업자는 까먹는다;
		 *  
		 *  난이도 9까지는 무슨 일이 있어도 해보자
		 *  
		 *   
		 *  
		 *  
		 *  
		 */
		
		
	}
}

